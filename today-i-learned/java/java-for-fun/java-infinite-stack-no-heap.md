---
description: >-
  "스택이 무한히 커질 수 있다면 힙은 필요 없을까?" 이 질문은 메모리 구조의 본질적인 목적에 대한 통찰을 요구하는 질문이다. 이 글에서는
  스택과 힙의 역할을 비교하고, 스택이 아무리 커져도 힙이 왜 여전히 필요한지를 알아보았다.
---

# 🥞 Java : Infinite Stack ≠ No Heap

## Stack vs Heap

| 항목       | Stack                | Heap               |
| -------- | -------------------- | ------------------ |
| 할당 시점    | 컴파일 타임 (주로), 함수 호출 시 | 런타임                |
| 할당/해제 방식 | 자동 (LIFO 구조)         | 수동 또는 GC           |
| 속도       | 빠름                   | 느림                 |
| 주요 용도    | 지역 변수, 함수 호출 스택      | 동적 객체, 불확정 크기 데이터  |
| 크기       | 제한적 (보통 MB 단위)       | 상대적으로 큼 (보통 GB 이상) |

## Why Stack Alone Isn't Enough

스택이 무한하다면, 이론적으로 대부분의 데이터를 스택에 보관할 수 있을 것처럼 보인다. \
그러나 메모리 용량이 아니라 메모리 **구조적 특성** 때문에 힙은 여전히 필요하다.

## Limitations of LIFO

스택은 LIFO 구조이므로 마지막에 들어간 데이터만 꺼낼 수 있다.\
&#x20;그러나 현실 프로그램에서는 다음과 같은 패턴이 자주 등장한다.

* 여러 함수에서 동일한 객체를 참조해야 하는 경우
* 콜백 함수나 비동기 로직으로 객체를 넘겨야 하는 경우
* GUI 요소처럼 오랫동안 살아있는 객체

이런 객체들은 스택 구조로는 다루기 어렵다. 따라서 자유로운 참조와 수명을 가진 힙이 필요하다.

## Object Lifetime Management

스택에 있는 변수는 함수가 종료되면 자동으로 사라진다.

```java
void foo() {
    Person p = new Person();  // 스택에 존재
}
// p는 여기서 소멸
```

하지만 다음과 같이 함수 밖에서도 살아남아야 하는 객체가 있다.

```java
public class Manager {
    private List<Person> team = new ArrayList<>();

    void addMember() {
        Person p = new Person();
        team.add(p);  // 함수 종료 후에도 p는 살아있어야 함
    }
}
```

이처럼 객체 수명이 함수보다 길 경우, 반드시 힙이 필요하다.

## Concurrency and Shared Objects

스택은 스레드마다 별도로 존재하므로, 스레드 간 데이터 공유가 불가능하다. \
반면 힙은 모든 스레드가 공유하는 메모리 공간으로, 다음과 같은 역할을 한다.

* 공유 자원 관리
* 스레드 간 통신
* 동시성 프로그래밍에서 객체 공유

따라서 병렬성을 위해서도 힙은 필수이다.

## Conclusion

스택이 아무리 커지더라도 힙은 구조적인 이유로 필수적이다. 요약하면 다음과 같다.

* 스택은 LIFO 구조로 범용 데이터 관리에 적합하지 않다.
* 함수 밖에서도 살아남는 객체는 스택에 둘 수 없다.
* 멀티스레드 환경에서 데이터 공유를 위해 힙이 필요하다.

즉, 스택의 크기와 무관하게 힙은 프로그래밍에 있어서 없어서는 안 될 메모리 구조이다.
