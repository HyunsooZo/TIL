---
description: Redis는 "Remote Dictionary Server"의 약자로, 오픈 소스 기반의 인메모리 데이터 구조 저장소
---

# 🟥 Redis

## Concept

Redis는 "Remote Dictionary Server"의 약자로, 오픈 소스 기반의 **인메모리 데이터 구조 저장소**다. \
단순히 키-값 저장소 역할뿐만 아니라, **다양한 데이터 구조**를 지원하여 DB, 캐시, 메시지 브로커 등으로 활용된다. \
데이터는 메모리에 저장되며, 이를 통해 매우 빠른 읽기 및 쓰기 성능을 제공한다.

Redis는 다음과 같은 데이터 구조를 지원한다:

* **String**: 일반적인 키-값 저장.
* **List**: 순서를 유지하는 값의 컬렉션.
* **Set**: 중복 없는 값의 집합.
* **Sorted Set**: 점수를 기준으로 정렬된 값의 집합.
* **Hash**: 필드-값 쌍으로 구성된 맵 형태.
* **Stream**: 실시간 데이터를 위한 스트림 처리.

또한, TTL(Time-To-Live) 기능을 통해 데이터 만료를 설정할 수 있으며, \
클러스터링과 복제를 통해 **확장성**과 **고가용성**을 지원한다. \
Redis는 매우 가벼운 설치와 설정 과정을 제공하며, \
다양한 프로그래밍 언어에서 쉽게 사용할 수 있는 클라이언트를 지원한다.

## Working Principles

Redis는 **단일 스레드 기반**의 **이벤트 루프 모델**로 동작한다. \
이 모델은 **비동기적으로 클라이언트의 요청을 처리**하며, \
효율적인 메모리 관리와 빠른 응답 속도를 보장한다.

### Flow

1. **클라이언트 요청**: 클라이언트가 Redis 서버에 명령(Command)을 보낸다.
2. **명령 파싱**: Redis 서버는 요청을 파싱하고 적절한 작업을 결정한다.
3. **데이터 처리**: 요청된 데이터를 메모리에서 검색하거나 수정한다.
4. **응답 반환**: 처리된 결과를 클라이언트에 반환한다.

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

## Why Redis Over Simple In-Memory Caching

누군가는 그럼 그냥 인메모리 캐싱하면 더빠를거아냐? 라고 말할 수도 있다. \
레디스로 캐싱하거나 레디스로 데이터를 저장하는게 더 나은이유는 다음과 같다.

1. **데이터 구조 지원**: \
   일반적인 인메모리 캐싱은 단순한 키-값 저장만 가능하지만, Redis는 다양한 데이터 구조를 제공한다.
2. **TTL 및 만료 기능**: \
   Redis는 각 데이터 항목에 TTL(Time-To-Live)을 설정하여 자동으로 만료시킬 수 있다.
3. **복제와 확장성**: \
   Redis는 클러스터링 및 복제를 통해 고가용성을 지원하며, 대규모 애플리케이션에 적합하다.
4. **데이터 영속성**: \
   단순 메모리 캐싱과 달리 Redis는 데이터를 디스크에 영속적으로 저장할 수 있어 데이터 유실을 방지한다.
5. **추가 기능**: \
   Pub/Sub 메시징, Lua 스크립팅, 트랜잭션 등 다양한 고급 기능을 제공한다.

## Difference Between RDB and AOF

### RDB (Redis DataBase)

* **방식**: 특정 시점(Snapshot)에 **메모리 데이터를 디스크에 저장.**
* **장점**:
  * 읽기 전용 환경에서 빠르고 간단.
  * 파일 크기가 작고 디스크 I/O 효율적.
* **단점**:
  * 저장 주기 사이에 발생한 데이터는 유실될 수 있음.
  * 실시간 데이터 백업에는 적합하지 않음.

### AOF (Append-Only File)

* **방식**: 실행된 **모든 명령을 로그 형태로 저장**.
* **장점**:
  * 데이터 손실 위험이 적음.
  * 명령 기반으로 데이터를 복구 가능.
*   **단점**:

    * 로그 파일 크기가 커질 수 있음.
    * 디스크 쓰기 I/O가 증가할 가능성.



## Complementary Usage of RDB and AOF

Redis는 **RDB와 AOF를 동시에 활성화**하여 단점을 상호 보완할 수 있다:

1. **RDB**: 정기적인 스냅샷을 저장하여 디스크 사용량을 최소화하고 빠르게 데이터 복구 가능.
2. **AOF**: 실시간 데이터를 로그로 저장하여 최신 상태를 보장.

### Recovery Scenario

* Redis는 RDB 파일로 기본 데이터를 복구한 뒤, AOF 로그를 재생하여 최신 데이터를 복구한다.
* 이를 통해 데이터 유실 가능성을 최소화하면서 빠른 복구를 제공한다.

<figure><img src="../../.gitbook/assets/스크린샷 2024-12-07 오후 10.35.30.png" alt=""><figcaption></figcaption></figure>

## Conclusion

Redis는 단순한 키-값 저장소를 넘어 다양한 데이터 구조와 고성능 처리 능력을 통해 \
**데이터베이스**, **캐시**, **메시지 브로커** 등 여러 역할을 수행할 수 있는 다재다능한 도구다.

인메모리 기반의 빠른 데이터 처리와 더불어, TTL, 데이터 복제, 클러스터링, 데이터 영속성 등 \
다양한 기능을 통해 **확장성**, **고가용성**, **안정성**을 제공한다.

특히 RDB와 AOF 방식을 결합한 데이터 영속성 관리 방식은 실시간 데이터와 대량 데이터 저장소 \
모두에 적합한 선택지가 될 수 있다. 이러한 이유로 Redis는&#x20;

**대규모 트래픽 처리**, **실시간 데이터 관리**, **높은 성능을 요구하는 애플리케이션**에서 널리 사용되고 있다.

결론적으로, Redis는 그 유연성과 기능성으로 인해 단순한 캐시 도구 이상의 가치를 제공하며, \
현대 애플리케이션의 필수 기술 스택 중 하나로 자리 잡고 있다. \
Redis를 잘 활용한다면, 데이터 처리 성능과 안정성을 모두 잡을 수 있을 것이다.
