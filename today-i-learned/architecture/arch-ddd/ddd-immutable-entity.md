---
description: >-
  DDD 프로젝트에서는 엔티티의 상태를 직접 변경하지 않고 새로운 엔티티를 생성하는 코드들을 자주 볼 수 있다. 이는
  불변성(immutability)과 관련된 설계 원칙에서 비롯되며, 아래와 같은 이유, 장점, 단점이 있다.
---

# ⚕️ DDD : Immutable Entity

## **Why?**

### **Immutable State**

엔티티를 불변으로 설계하면 동시성 문제와 예측 불가능한 상태 변화를 방지할 수 있다.\
예: 엔티티가 공유 리소스나 멀티스레드 환경에서 안전하게 사용할 수 있음.

### **Audit Trail**

새로운 엔티티를 생성하면 변경 전후의 상태를 명확히 분리할 수 있어 이력을 쉽게 추적 가능.\
예: 변경 내역이 필요하거나 데이터 버전을 관리해야 하는 경우.

### **Functional Programming**

함수형 프로그래밍의 영향을 받아 데이터 변경 대신 새로운 객체를 생성하는 방식 채택.

### **Prevention of JPA Issue**&#x20;

영속성 컨텍스트에서 관리되는 엔티티의 상태를 변경하면 의도치 않은 업데이트가 발생할 수 있음.\
새로운 엔티티를 생성하면 이런 문제를 완전히 방지 가능.

### **Explicit Change**

상태를 복사하고 수정하여 새로운 객체를 반환하는 방식은 변경이 코드에서 더 명확히 드러남.

***

## Pros

### Thread-Safe Concurrency

* 여러 스레드에서 동일한 엔티티를 참조해도 안전.
* 변경 불가능한 객체는 스레드 동기화가 필요 없음.

### **Easy Change Tracking**

* 새 엔티티를 생성하면 이전 상태와 변경된 상태를 쉽게 비교 가능.
* 변경 이력을 저장하거나 로깅하는 작업이 간단.

### **Clear Intent**

* 새로운 엔티티 생성으로 상태 변화를 명확히 드러냄.
* 복잡한 비즈니스 로직에서도 의도된 동작을 더 쉽게 파악 가능.

### **Enhanced Encapsulation**

* 엔티티의 내부 상태를 외부에서 직접 변경하지 않으므로 캡슐화 원칙 준수.

### **Improved Maintainability**

* 코드가 명시적이고 의도적이므로 디버깅과 유지보수가 용이.

***

## **Cons**

### Increased Memory Usage

* 새로운 엔티티 생성은 기존 객체를 복사하거나 새로운 메모리를 할당하므로 메모리 소모가 증가.
* 특히 대규모 데이터 처리가 필요한 경우 비효율적일 수 있음.

### **Performance Overhead**

* 복사나 새 객체 생성 과정에서 성능 오버헤드 발생.
* 빈번한 객체 생성이 필요한 경우 GC(Garbage Collection) 부담 증가.

### **Increase Complexity**

* 상태가 자주 변경되는 도메인에서는 변경된 상태마다 \
  새로운 객체를 생성해야 하므로 코드가 복잡해질 수 있음.

### **Awkardness with JPA**

* JPA는 엔티티 상태 변경 및 dirty checking에 최적화되어 있음.
* 매번 새 엔티티를 생성하면 JPA와의 시너지가 약화될 수 있음.

***

## Conclusion

새로운 엔티티를 생성하는 방식은 **안정성과 명확성**을 추구하지만, \
성능과 메모리 사용 측면에서 주의가 필요하다.

### Best Use Cases :

* 동시성이 중요한 시스템 일 때
* 변경 이력 추적이 필요한 비즈니스 일 때
* 비즈니스 로직에서 상태 변경이 드물거나 객체 크기가 작을 때

### Situations Requiring Caution **:**

* 빈번한 상태 변경과 대규모 데이터 처리 환경.\
  이 경우 성능 최적화를 위해 기존 엔티티 변경을 고려할 수도 있음.
