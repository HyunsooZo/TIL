---
description: 도메인 주도 개발/설계 방법론
---

# 🔷 Domain-Driven Design(DDD)

## Domain-Driven Design (DDD)란?

Domain-Driven Design(DDD)은 소프트웨어 설계 접근법으로, \
복잡한 비즈니스 문제를 해결하기 위해 **도메인 모델을 중심으로 시스템을 설계**하고 **개발**하는 방법론이다. \
DDD는 비즈니스 전문가와 개발자 간의 긴밀한 협력을 통해 도메인을 깊이 이해하고, \
그 이해를 코드에 반영하여 복잡한 문제를 해결하는 데 중점을 둔다. \
이를 통해 시스템을 더 나은 구조로 만들고, 비즈니스와 기술 간의 간극을 좁히는 것을 목표로 한다.

## DDD의 핵심 요소

### **1. 도메인 (Domain)**

도메인은 해결하려는 특정 비즈니스 문제의 영역을 의미한다. \
예를 들어, "전자 상거래"라는 도메인에서는 사용자, 상품, 주문, 결제 등이 주요 개념이 될 수 있다.

### **2. 서브 도메인 (Subdomain)**

도메인은 일반적으로 여러 개의 하위 도메인으로 나뉘며, 각 서브 도메인은 특정 비즈니스 기능에 초점을 맞춘다. \
예를 들어, 전자 상거래 도메인은 '사용자 관리', '상품 관리', '주문 처리', '결제 처리' 등으로 나눌 수 있다.

**3. 바운디드 컨텍스트 (Bounded Context)**

바운디드 컨텍스트는 모델이 명확하게 정의되고 적용되는 경계를 의미한다. \
DDD에서는 바운디드 컨텍스트 안에서 모델의 의미가 일관되도록 관리한다. \
예를 들어, "주문"이라는 개념은 `주문 관리` 컨텍스트와 `결제 처리` 컨텍스트에서 다르게 해석될 수 있으므로, \
각각의 컨텍스트에서 독립적으로 관리된다.

**4. 유비쿼터스 언어 (Ubiquitous Language)**

DDD에서는 비즈니스 전문가와 개발자 간의 소통을 원활하게 하기 위해, \
도메인 언어를 사용하여 일관성 있게 대화한다. \
이는 코드와 문서, 대화에서 모두 사용되는 공통 언어를 만드는 것이다.

**5. 엔티티 (Entity)**

엔티티는 고유 식별자(ID)를 가지고 있는 객체로, 시스템 내에서 지속되면서 상태가 변할 수 있다. \
예를 들어, `사용자(User)` 엔티티는 고유 ID를 가지고 있으며, 이름이나 이메일 주소와 같은 속성이 변경될 수 있다.

**6. 값 객체 (Value Object)**

값 객체는 식별자가 필요 없는 객체로, 불변성을 가지며 도메인 내에서 하나의 값으로 사용된다. \
예를 들어, 주소(Address)는 사용자의 속성으로 쓰일 수 있는 값 객체이다. \
주소가 변경되면 새로운 값 객체로 교체하는 방식으로 관리된다.

**7. 애그리거트 (Aggregate)**

애그리거트는 관련된 엔티티와 값 객체를 그룹화하여 일관성을 유지하는 경계를 설정하는 개념이다. \
하나의 애그리거트에는 반드시 루트 엔티티가 있으며, 외부에서 애그리거트의 상태를 변경하려면 \
루트 엔티티를 통해야 한다.

**8. 리포지토리 (Repository)**

리포지토리는 애그리거트의 저장 및 조회를 책임지는 객체로, \
애그리거트를 영구 저장소(예: 데이터베이스)와 연결한다. \
애그리거트는 주로 리포지토리를 통해 생성, 조회, 저장된다.

**9. 도메인 서비스 (Domain Service)**

도메인 서비스는 특정 엔티티에 국한되지 않고, 여러 엔티티에 걸쳐있는 비즈니스 로직을 캡슐화한다. \
예를 들어, `배송비 계산`과 같은 로직은 여러 엔티티를 참조해야 하므로, 별도의 도메인 서비스로 구현할 수 있다.

## DDD의 흐름

<figure><img src="../../.gitbook/assets/스크린샷 2024-11-05 오후 8.35.00.png" alt=""><figcaption></figcaption></figure>

## DDD의 장점과 단점

### **장점**

1. **도메인 이해도 향상**: \
   도메인 전문가와 개발자가 동일한 언어를 사용함으로써, 비즈니스 로직에 대한 이해가 높아진다.
2. **유지보수 용이성**: \
   코드가 비즈니스 로직과 일치하여, 시스템을 쉽게 이해하고 수정할 수 있다.
3. **확장성**: \
   바운디드 컨텍스트를 기반으로 시스템을 확장할 수 있어, 새로운 기능을 독립적으로 추가하기 용이하다.

### **단점**

1. **복잡한 초기 설계**: \
   DDD는 초기 설계에 많은 시간과 노력이 필요하다. 도메인을 깊이 이해하고 모델링하는 과정이 복잡할 수 있다.
2. **작은 프로젝트에는 비효율적**: \
   DDD는 복잡한 도메인에서 특히 유리하지만, 단순한 시스템에는 오히려 과도한 설계가 될 수 있다.
3. **높은 학습 비용**: \
   DDD의 개념과 원칙을 숙지하고 적용하는 데 시간이 걸릴 수 있다. \
   특히 개발자 간에 개념을 공유하고 일관되게 적용하는 것이 어렵다.

## DDD 를 접하며

DDD 방법론을 완벽하게 이해하고 적용하는 것이 쉬운 일은 아니었다.\
회사에서도 처음 DDD 구조를 접했을 때는 진입 장벽이 꽤 높았지만, \
그 구조를 제대로 이해하고 활용하면서 느낀 점은 **유지보수성이 뛰어나다는 것**이었다.

처음에는 설계 및 모델링 작업이 시간이 많이 소요될 수 있다. 실제 내가 진행중인 프로젝트에서도 그렇다.\
도메인에 대한 깊은 이해가 필요하고, 도메인을 잘못 정의하면 이후에 수정하는 데 많은 비용이 들 수 있기 때문이다. \
그러나 일단 제대로 된 도메인 모델이 구축되면, 코드가 비즈니스 요구 사항과 일관되게 맞물려 동작하게 되며, \
덕분에 유지보수와 확장이 매우 용이해진다.

DDD를 적용한 시스템은 코드가 곧 비즈니스의 흐름을 반영하므로, \
개발자들이 비즈니스 로직을 이해하기 쉬워지고 요구 사항 변경에도 유연하게 대응할 수 있게 된다. \
이러한 점에서 DDD는 초기 난이도가 있지만, 복잡한 도메인과의 상호작용이 많은 시스템에서 \
장기적으로 볼 때 매우 유리한 선택이라고 생각하며 앞으로 이런 유지보수에 유리한 설계/개발을 이어가려한다.

