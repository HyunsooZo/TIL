---
description: written by 조성호
---

# ⚙️ 쉽게 배우는 운영체제

### 짧은 후기

여러 개인사정이 겹쳐 예상보다 꽤 오랜기간 동안 읽게 된 책이었다. \
그동안 운영체제는 단순히 백엔드 개발과는 다소 거리가 있다고 생각했지만, \
이 책을 읽으면서 그 중요성을 깨닫게 되었다. 예시나 책 내용이 이 전에 읽은 책들처럼 \
눈에 확 들어오거나 어떤 흥미를 지속적으로 끌어내는 책은 아니라고 생각한다. \
하지만 운영체제의 기초를 탄탄히 담고 있고, 이를 통해 운영체제의 역할을 _얼추_(?) 이해함으로써\
서버 개발 시 성능 최적화에 대한 통찰을 _어느정도_(?) 얻을 수 있었다고 말하고 싶다.\
\
특히, 메모리 관리와 스케줄링 같은 부분은 서버의 자원 할당과 관련이 많아 매우 유익했다고 생각되는데\
프로세스 관리에서 배운 교착상태나 스레드 활용법도, 멀티스레딩 환경에서 발생할 수 있는 \
문제들을 해결하는 데 큰 도움이 될 것 같다. \
\
가상 메모리와 페이징 기법은 대용량 데이터를 다루는 시스템에서 메모리 관리의 효율성을 높이는 데 중요한 개념이었다. 파일 시스템과 디스크 관리에 대한 내용 또한 서버에서 파일을 다루는 방식이나 데이터 저장 최적화에 \
실질적인 도움이 될 수 있을 것 같았다.

특히 클라우드 컴퓨팅에 대해 다룬 부분은 현재 많이 사용하는 AWS 같은 기술의 이론적 기반을 \
이해하는 데 도움이 될 것 같다.&#x20;

### 책 정리

<details>

<summary>Chapter 2 : 컴퓨터의 구조 와 성능 향상</summary>

**컴퓨터의 기본 구성**\
**- CPU (Central Processing Unit)**: 컴퓨터의 두뇌, 명령 처리/계산 수행.\
\- **메모리 (Memory)**: 데이터 임시 저장소, 프로그램 실행에 필요한 정보 저장.(ex: ram)\
\- **저장 장치 (Storage)**: 데이터를 영구적으로 저장 (ex: 하드디스크 SSD)\
\- **입출력 장치 (I/O Devices)**: 키보드, 마우스, 모니터 같은 장치

**컴퓨터 성능 향상 기술**\
**- 버퍼 :** 속도 차이를 극복하기 위해 데이터를 임시 저장하는 공간, 주로 입출력 장치와 CPU 사이에서 사용.\
\- **캐시 :** 자주 사용하는 데이터를 미리 저장해 접근 속도를 높이는 고속 메모리.\
\- **저장장치 계층 구조 :** 속도에 따라 레지스터, 캐시, 주 메모리, 보조 저장장치로 나눠 데이터를 효율적 관리.\
\- **인터럽트**는 CPU가 외부 이벤트에 즉시 반응해 중요한 작업을 처리한 후 원래 작업으로 돌아가게 하는 기술.

**병렬처리** \
**- 파이프라인 기법:**\
&#x20;  \- 명령어 처리 과정을 여러 단계로 나눠서 각 단계를 동시에 실행하는 방식\
&#x20;  \- 한 명령어가 실행될 때, 다른 명령어는 다음 단계로 준비될 수 있어 여러 명령어를 겹쳐 처리할 수 있음.\
**- 슈퍼스칼라 기법:**\
&#x20;  **-** 여러 개의 명령어를 동시에 처리하는 CPU 구조.\
&#x20;  \- 파이프라인을 여러 개 둬서 여러 명령어를 병렬로 실행할 수 있어 성능을 크게 향상.\
\- **슈퍼파이프라인 슈퍼스칼라기법**\
&#x20;  **-** 파이프라인 기법과 슈퍼스칼라 기법을 결합한 방식.\
&#x20;  \- 파이프라인의 단계 수를 더 세분화하고, 여러 명령어를 동시 처리할 수 있도록 해 병렬 처리 효율을 극대화\
\
**슈퍼 파이프라인 기법**\
&#x20;  **-** 파이프라인의 각 단계를 더 세분화해서, 한 단계의 작업 시간이 매우 짧아지도록 하는 방식.\
&#x20;  \- 이를 통해 더 많은 명령어를 동시에 처리할 수 있어 처리 속도를 높힘.\
\
**VLIW (Very Long Instruction Word) 기법**\
&#x20;  **-** 한 번에 여러 연산을 할 수 있는 긴 명령어를 사용해 병렬 처리를 수행하는 방식.\
&#x20;  \- 컴파일러가 여러 연산을 하나의 명령어로 묶어 실행하도록 최적화해서 하드웨어 부담을 줄이고, 명령어의 병렬 처리를 극대화.

</details>

<details>

<summary>Chapter 3 : 프로세스와 스레드</summary>

**1. 프로세스의 개념**\
**-** 프로세스는 실행 중인 프로그램이다. 즉, 메모리에 올라가 실제로 동작하는 단위이다.\
\
**2. 프로그램에서 프로세스로의 전환**\
**-** 프로그램이 메모리에 적재되어 CPU가 실행하면 프로세스로 전환된다.\
\
**3. 프로세스의 상태**\
&#x20;**3-1. 프로세스의 네 가지 상태**\
&#x20;  **-** 생성 (New): 프로세스가 생성된 상태.\
&#x20;  \- 준비 (Ready): CPU 할당을 기다리는 상태.\
&#x20;  \- 실행 (Running): CPU를 할당받아 명령을 실행 중인 상태.\
&#x20;  \- 종료 (Terminated): 프로세스가 종료된 상태.\
&#x20; **3-2. 프로세스의 다섯 가지 상태**\
&#x20;  **-** 생성 (New): 생성된 상태.\
&#x20;  **-** 준비 (Ready): 실행 대기 상태.\
&#x20;  **-** 실행 (Running): 명령을 실행 중인 상태.\
&#x20;  **-** 대기 (Waiting/Blocked): I/O 작업 등으로 대기하는 상태.\
&#x20;  **-** 종료 (Terminated): 프로세스가 종료된 상태.

**4. 프로세스 제어 블록 (PCB)과 문맥 교환**\
&#x20;  **-** PCB는 프로세스에 대한 정보를 저장하는 자료구조이다.\
&#x20;  **-** 문맥 교환은 CPU가 실행 중인 프로세스를 다른 프로세스로 전환하는 절차이다.

&#x20; **4-1. 프로세스 컨텍스트 스위칭 절차**\
&#x20;   **-** 실행 중인 프로세스의 상태를 PCB에 저장함.\
&#x20;   **-** 새 프로세스의 PCB 정보를 CPU 레지스터에 로드함.\
&#x20;   **-** 새로운 프로세스 실행을 시작함.

**5. 프로세스의 연산**

**5-1. 프로세스의 구조**\
**-** 프로세스는 코드, 데이터, 스택, 힙으로 구성된다.

**5-2. 프로세스의 생성과 복사**\
**-** 프로세스는 시스템 호출(fork 등)을 통해 생성된다. 부모 프로세스는 자식 프로세스를 복사해 생성함.

**5-3. 프로세스의 전환**\
**-** 프로세스는 CPU 스케줄러에 의해 다른 프로세스로 전환된다.

**6. 프로세스 계층구조**\
**-** 프로세스는 부모-자식 관계를 가지며 트리 구조를 형성. 부모 프로세스는 자식 프로세스를 생성/ 관리

**7. 스레드의 개념**

**7-1. 스레드 정의**\
&#x20;**-** 스레드는 프로세스 내에서 독립적으로 실행되는 흐름이다.

**7-2. 프로세스와 스레드 차이**\
&#x20;**-** 프로세스는 독립된 실행 단위이며, 메모리 공간을 따로 사용함.\
&#x20;\- 스레드는 프로세스 내에서 실행되는 작은 단위이며, 메모리 공간을 공유함.

**8. 멀티스레드의 기본 개념**\
&#x20;**-** 멀티스레드는 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 방식을 말한다.\
&#x20;\- 각 스레드는 독립적인 실행 흐름을 가지지만, 같은 메모리 공간(코드, 데이터, 힙)을 공유한다.\
&#x20;\- 멀티스레드를 사용하면 CPU 자원을 효율적으로 사용, 응답성을 높이며, 여러 작업을 동시에 처리할 수 있다.\
&#x20;\- 대표적인 사용 사례로는 웹 서버, 게임, 동영상 처리 프로그램 등이 있다. 각 작업이 독립적일 때 병렬로 처리함으로써 성능을 극대화할 수 있다.

**9. 멀티스레드 구조와 예**\
**-** 멀티스레드는 하나의 프로세스에서 여러 스레드가 동시에 실행되는 구조이다. \
&#x20;  예: 웹 브라우저는 여러 탭을 각각 스레드로 처리함.

</details>

<details>

<summary>Chapter 4 : 스케줄링</summary>

1\. **스케줄링의 개념**\
&#x20;  **- 스케줄링**은 CPU를 각 프로세스에 적절히 할당해 효율적으로 시스템을 운영하는 방법이다.

2\. **스케줄링의 단계 (규모에 따라 분류)**\
&#x20;**2-1. 고수준 스케줄링**\
&#x20;  **-** 어떤 프로세스가 실행할 자격이 있는지 결정하는 단계. 주로 새로운 프로세스를 생성할지 여부를 결정.

**2-2. 중간수준 스케줄링**\
&#x20;  **-** 실행 대기 중인 프로세스 중 일부를 스왑(메모리에서 디스크로 내보내거나 반대로 불러오는 작업)해서 \
&#x20;    메모리 관리를 최적화하는 단계.

**2-3. 저수준 스케줄링**\
&#x20;  **-** CPU에 어떤 프로세스를 할당할지 결정하는 단계. 실행 대기 중인 프로세스 중 하나를 선택해 CPU 할당

#### 3. **스케줄링의 목적**

&#x20;  **-** 프로세스의 효율적인 실행을 보장하고 CPU 자원을 최대 활용\
&#x20;  **-** 처리량 증가, 응답 시간 단축, 공정성 유지 등의 목표 지향.\
\
**4. 스케줄링의 종류**

**4-1. 선점형 스케줄링**\
&#x20;  **-** 프로세스가 실행 중일 때, 더 우선순위가 높은 프로세스가 있으면 CPU를 강제로 빼앗을 수 있다.\
&#x20;  **-** 예: Round Robin, 우선순위 기반 스케줄링.

**4-2. 비선점형 스케줄링**\
&#x20;  **-** 한 프로세스가 CPU를 할당받으면 그 프로세스가 끝날 때까지 CPU를 다른 프로세스가 가져갈 수 없다.\
&#x20;  **-** 예: FIFO, SJF(Shortest Job First).

#### 5. **프로세스 우선순위**

&#x20;  **-** 각 프로세스에 우선순위를 부여해, 높은 우선순위를 가진 프로세스가 먼저 CPU를 할당받는다.\
&#x20;  **-** 우선순위는 시스템에 의해 정해지거나 사용자가 직접 설정할 수 있다.

#### 6. **다중 큐 스케줄링**

&#x20;  **-** 프로세스를 여러 개의 큐로 나눠 각 큐마다 다른 스케줄링 알고리즘을 적용한다.\
&#x20;  **-** 예: 실시간 프로세스는 높은 우선순위 큐에, 일반 프로세스는 낮은 우선순위 큐에 할당.

#### 7. **스케줄링 알고리즘**

**7-1. 스케줄링 알고리즘 선택 기준**\
&#x20;  **- 처리량(Throughput)**: 일정 시간 동안 처리된 프로세스의 수.\
&#x20;  **- 대기 시간(Waiting Time)**: 프로세스가 CPU를 할당받기 전까지의 대기 시간.\
&#x20;  **- 응답 시간(Response Time)**: 프로세스가 시작된 후 첫 번째 응답을 받기까지 걸리는 시간.\
&#x20;  **- 공정성(Fairness)**: 모든 프로세스가 공정하게 CPU를 할당받는지 여부.

**7-2. 스케줄링 알고리즘의 종류**\
&#x20;  **- FCFS (First-Come, First-Served)**: 먼저 도착한 프로세스가 먼저 실행된다. 비선점형.\
&#x20;  **- SJF (Shortest Job First)**: 실행 시간이 짧은 프로세스부터 처리한다. 비선점형.\
&#x20;  **- Round Robin**: 각 프로세스가 동일한 시간만큼 CPU를 할당받는다. 선점형.\
&#x20;  **- Priority Scheduling**: 우선순위가 높은 프로세스가 먼저 실행된다. 선점형/비선점형 모두 가능\
&#x20;  **- Multilevel Queue**: 프로세스를 여러 큐로 나누어 각 큐에서 다른 스케줄링 알고리즘을 적용.

</details>

<details>

<summary>Chapter 5 : 프로세스 동기화</summary>

**1. 프로세스 간 통신 (IPC: Inter-Process Communication)**\
**- 개념**: \
&#x20;    프로세스 간 데이터를 주고받는 방법. \
&#x20;    독립적으로 실행되는 프로세스들이 필요한 데이터를 주고받아야 할 때 사용.\
\- **분류**:\
&#x20;    **직접 통신**: 프로세스가 서로 직접적으로 데이터를 주고받는다.\
&#x20;    **간접 통신**: 프로세스가 중간 매개체(메시지 큐, 공유 메모리 등)를 통해 데이터를 주고받는다.\
\- **종류**:\
&#x20;    **메시지 전달(Message Passing)**: 데이터를 작은 메시지로 교환함.\
&#x20;    **공유 메모리(Shared Memory)**: 두 프로세스가 같은 메모리 공간을 공유하여 데이터를 주고받음.\
&#x20;    **파이프(Pipe)**: 하나의 프로세스 출력이 다른 프로세스의 입력으로 연결됨.\
&#x20;    **소켓(Socket)**: 네트워크를 통해 데이터를 주고받음.

**2. 공유자원과 임계구역**

**2-1. 공유자원 개념/접근**\
**- 공유자원**: 여러 프로세스가 동시에 접근할 수 있는 자원이다. 메모리, 파일, 데이터베이스 등이 있다.\
\- **접근**: 프로세스들은 공유자원에 접근할 때 충돌이 발생하지 않도록 관리 필요. 임계구역 문제는 여기서 발생

**2-2. 임계구역 (Critical Section)**\
**- 임계구역**은 공유자원에 대해 하나의 프로세스만 접근할 수 있도록 보장해야 하는 코드 영역이다. 여러 프로세스가 동시에 접근하면 충돌이나 데이터 불일치가 발생할 수 있음.

**2-3. 생산자/소비자 문제**\
**- 생산자/소비자 문제**는 한쪽에서는 데이터를 생성(생산자)하고, 다른 쪽에서는 데이터를 소비(소비자)하는 상황에서 발생하는 공유자원 접근 문제이다. 두 프로세스 간의 데이터 버퍼(임계구역)를 효율적으로 관리해야 함.

**2-4. 임계구역 해결조건**\
**- 상호 배제 (Mutual Exclusion)**: 한 프로세스가 임계구역을 사용하는 동안 다른 프로세스는 접근하지 못해야 함.\
\- **진행 (Progress)**: 임계구역이 비어있을 때는 어느 프로세스가 접근할지 결정해야 함.\
\- **한정된 대기 (Bounded Waiting)**: 프로세스는 무한정 대기하지 않고 일정한 시간 안에 임계구역에 들어갈 수 있어야 함.

**3.** **임계구역 해결방법**

**3-1. 임계구역 해결조건을 고려한 설계**\
**- 소프트웨어적 해결방법**:\
&#x20;   **Mutex (뮤텍스)**: 임계구역에 접근할 때 잠금(Lock)과 해제(Unlock)를 통해 상호 배제를 보장함.\
&#x20;   **세마포어 (Semaphore)**: 정수값을 사용해 여러 프로세스가 자원에 접근하는 순서를 제어함.\
&#x20;   **모니터 (Monitor)**: 프로세스들이 공유 자원을 사용할 때 동기화를 제공하는 고수준 동기화 방법.

</details>

<details>

<summary>Chapter 6 : 교착 상태</summary>

**1.** **교착상태(Deadlock) 개요**

**1-1. 교착상태 정의**\
**- 교착상태**는 두 개 이상의 프로세스가 서로 상대방의 자원을 기다리며 무한히 대기하는 상태.

**1-2. 교착상태 발생**\
**-** 교착상태는 프로세스들이 자원을 독점하려고 할 때 발생함. 자원이 반납되지 않으면 해결되지 않음.

**1-3. 자원 할당 그래프**\
**- 자원 할당 그래프**는 프로세스와 자원의 상태를 나타냄. 프로세스가 자원을 요청하거나 할당받은 관계를 시각화한 그래프.\
&#x20;  \- **노드**: 프로세스 또는 자원.\
&#x20;  \- **엣지**: 자원 요청 또는 할당 관계.\
&#x20;  \- **교착상태 발생 여부**: 사이클이 존재하면 교착상태가 발생할 가능성이 있음.

**2. 교착상태 필요조건**\
**-** 교착상태가 발생하기 위해서는 다음 네 가지 조건이 동시에 만족되어야 함.\
&#x20; 1\. **상호 배제 (Mutual Exclusion)**: 한 번에 하나의 프로세스만 자원을 사용할 수 있음.\
&#x20; 2\. **점유와 대기 (Hold and Wait)**: 자원을 점유한 상태에서 다른 자원을 요청하며 대기함.\
&#x20; 3\. **비선점 (No Preemption)**: 자원을 강제로 회수 불가. 자원을 할당받은 프로세스가 자발적으로 해제  할 때까지 기다림.\
&#x20; 4\. **순환 대기 (Circular Wait)**: 자원 요청이 순환적으로 이루어져 있어 서로가 상대방의 자원을 기다림.

**3. 교착상태 해결/예방 방법**\
**- 교착상태 예방**: 교착상태의 필요조건 중 하나 이상을 만족하지 않도록 시스템을 설계함.\
\- **상호 배제 방지**: 자원을 동시에 공유 가능하게 만듦.\
\- **점유와 대기 방지**: 자원을 요청하기 전에 모든 자원을 한 번에 할당받게 함.\
\- **비선점 방지**: 자원이 필요하면 이미 할당된 자원을 강제로 회수하게 함.\
\- **순환 대기 방지**: 자원에 순서를 부여해 프로세스들이 그 순서대로만 자원을 요청하게 함.

**4. 교착상태 회피**\
**- 회피**는 자원 요청 시 교착상태가 발생할 가능성을 미리 분석, 교착상태가 발생하지 않는 경우에만 자원 할당.\
&#x20;  \- **은행가 알고리즘(Banker's Algorithm)**: \
&#x20;     프로세스의 자원 요청이 시스템의 안전성을 해치지 않는 경우에만 자원 할당.

**5. 교착상태 검출**\
**- 검출**은 교착상태가 발생했는지 여부를 확인하는 방법.\
\- 자원 할당 그래프에서 **사이클**을 탐지하여 교착상태를 발견함.\
\- 교착상태가 발생하면 해당 프로세스를 강제로 종료하거나 자원을 회수해 문제를 해결함.

</details>

<details>

<summary>Chapter 7 : 물리 메모리 관리</summary>

1\. **물리 메모리 관리**

**1-1. 메모리 관리의 복잡성**\
**-** 메모리 관리는 여러 프로세스가 제한된 메모리 자원을 효율적으로 사용하도록 하는 과정에서 복잡해짐.

**1-2. 메모리 관리의 이중성**\
**-** 메모리 관리는 물리 메모리와 가상 메모리 간의 매핑을 통해 이루어짐. 즉, 실제 하드웨어와 사용자 프로세스 간의 메모리 공간을 적절히 관리해야 함.

**1-3. 메모리 관리의 역할**\
**-** 메모리 관리는 프로세스들이 각기 독립적으로 메모리 자원을 사용할 수 있도록 할당 및 회수함. 또한, 메모리의 효율적 사용을 보장함.

#### 2. **메모리 주소**

**2-1. 32bit CPU와 64bit CPU 차이**\
**- 32bit CPU**는 4GB의 메모리만 참조 가능. **64bit CPU**는 훨씬 더 큰 메모리 공간(이론상 16EB)을 참조할 수 있음.

**2-2. 절대주소와 상대주소**\
**- 절대주소:** 메모리에서 특정 위치를 직접 지정하는 주소.\
\- **상대주소:** 기준 주소에서의 오프셋을 나타내는 주소로, 프로그램 실행 시 실제 메모리 주소로 변환됨.

#### 3. **단일 프로그래밍 환경에서의 메모리 할당**

**3-1. 메모리 오버레이**\
**-** 메모리 크기가 작은 환경에서 필요한 데이터나 코드를 메모리에 부분적으로 적재하는 방법. 현재 필요한 부분만 메모리에 올림으로써 메모리 사용을 최소화함.

**3-2. 스왑**\
**-** 메모리가 부족할 때, 실행 중인 프로세스를 일시적으로 디스크로 내보내고 필요 시 다시 메모리로 불러오는 방식. 주로 다중 프로그래밍 환경에서 사용됨.

#### 4. **다중 프로그래밍 환경에서의 메모리 할당**

**4-1. 메모리 분할 방식**\
**-** 물리 메모리를 여러 개의 파티션으로 나누어 각 프로세스에게 할당하는 방식.

**4-2. 가변/고정 분할 방식**\
**- 고정 분할 방식**: 메모리를 고정 크기의 여러 파티션으로 나누고 각 프로세스에 할당함. 메모리 낭비가 발생할 수 있음.\
\- **가변 분할 방식**: 프로세스가 필요로 하는 만큼의 메모리를 할당함. 메모리 단편화 문제가 발생할 수 있음.

</details>

<details>

<summary>Chapter 8 : 가상 메모리 기초</summary>

**1.** **가상 메모리 개요**

**1-1. 가상 메모리 시스템**\
**- 개념**: 가상 메모리는 실제 물리 메모리보다 큰 메모리 공간을 제공하는 기법. 프로그램이 전체 메모리를 모두 사용하는 것처럼 동작하게 함.\
\- **매핑 테이블 필요성/역할**: 가상 주소와 실제 물리 주소를 매핑하기 위해 매핑 테이블이 필요함. 이 테이블을 통해 가상 주소가 물리 메모리로 변환됨. 페이지 테이블이 대표적인 매핑 테이블임.

#### 2. **페이징 기법**

**2-1. 페이징 기법 구현**\
**-** 물리 메모리와 가상 메모리를 고정 크기의 블록(페이지)으로 나눔. 각 페이지는 같은 크기이며, 프로그램은 필요한 페이지를 물리 메모리에 적재해 사용함.

**2-2. 페이징 기법 주소변환**\
**- 주소변환 과정**: 가상 주소를 페이지 번호와 오프셋으로 나눔. 페이지 번호는 페이지 테이블을 통해 물리 메모리의 프레임 번호로 변환되고, 오프셋은 해당 프레임에서 실제 주소를 결정함.

**2-3. 페이지 테이블 관리**\
**- 페이지 테이블**은 가상 페이지 번호와 물리 메모리의 프레임 번호를 매핑하는 역할을 함. 이 테이블은 메모리 내부에 저장됨.

**2-4. 페이지 테이블 매핑 방식**\
**- 직접 매핑**: 각 페이지가 하나의 고정된 프레임에 매핑됨.\
\- **다단계 페이지 테이블**: 페이지 테이블을 여러 단계로 나누어 메모리를 효율적으로 사용함.\
\- **연관 메모리(Associative Memory)**: 빠른 검색을 위해 페이지 테이블을 캐시에 저장해 자주 사용하는 페이지 정보를 빠르게 찾음.

**3.** **세그멘테이션 기법**

**3-1. 세그멘테이션 기법 구현**\
**-** 프로그램을 논리적인 단위(세그먼트)로 나눔. 각 세그먼트는 서로 다른 크기를 가지며, 코드, 데이터, 스택 등 논리적으로 나누어진 부분을 다룰 수 있음.

**3-2. 세그멘테이션 기법 주소 변환**\
**-** 세그먼트 번호와 오프셋으로 가상 주소를 나누고, 세그먼트 테이블을 통해 물리 메모리 상의 세그먼트 시작 주소로 변환한 후 오프셋을 더해 실제 주소를 얻음.

4\. **세그멘테이션-페이징 혼용 기법**

**4-1. 메모리 접근 권한**\
**-** 세그멘트별로 메모리 접근 권한을 설정할 수 있음. 예를 들어, 코드 세그먼트는 읽기 전용, 데이터 세그먼트는 읽기/쓰기 가능하게 설정함.

**4-2. 세그멘테이션-페이징 혼용 기법 도입**\
**-** 세그멘테이션과 페이징 기법을 결합하여, 세그먼트를 페이지 단위로 나누어 관리함. 이를 통해 메모리 관리를 더욱 유연하게 처리할 수 있음.

**4-3. 세그멘테이션-페이징 혼용 기법 주소변환**\
**-** 가상 주소는 세그먼트 번호, 페이지 번호, 오프셋으로 구성됨. 먼저 세그먼트 테이블을 참조하여 해당 세그먼트의 페이지 테이블을 찾고, 페이지 테이블을 통해 물리 주소로 변환함.

</details>

<details>

<summary>Chapter 9 : 가상 메모리 관리</summary>

**1.** **요구 페이징**

**1-1. 개요**\
**- 요구 페이징**은 프로그램 실행 시 필요한 페이지만 메모리에 적재하는 방식. 처음부터 모든 페이지를 메모리에 적재하지 않고, 필요한 시점에 페이지를 불러옴.

**1-2. 페이지 테이블 엔트리 구조**\
**- 페이지 테이블 엔트리(PTE)**는 각 페이지의 상태를 나타내는 정보를 포함함.\
&#x20;   \- **프레임 번호**: 해당 페이지가 매핑된 물리 메모리의 프레임 번호.\
&#x20;   \- **유효 비트(Valid Bit)**: 페이지가 메모리에 존재하는지 여부.\
&#x20;   \- **변경 비트(Dirty Bit)**: 페이지가 수정되었는지 여부\
&#x20;   \- **참조 비트(Reference Bit)**: 페이지가 최근에 참조되었는지 여부.

**1-3. 페이지 부재 (Page Fault)**\
&#x20;   **-** 프로세스가 필요한 페이지가 메모리에 없는 경우 발생하는 현상. \
&#x20;   \- 이때 운영체제는 페이지를 디스크에서 메모리로 불러옴. 페이지 부재 발생 시 실행 속도가 느려질 수 있음.

2\. **페이지 교체 알고리즘**

**2-1. 무작위 페이지 교체(Random Page Replacement)**\
**-** 교체할 페이지를 임의로 선택해 교체함. 구현이 간단하지만 비효율적임.

**2-2. FIFO 페이지 교체 (First-In, First-Out)**\
**-** 가장 먼저 메모리에 들어온 페이지를 교체함. 오래된 페이지가 가장 먼저 교체되므로 비효율적일 수 있음.

**2-3. 최적 페이지 교체 (Optimal Page Replacement)**\
**-** 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체함. 이론상 가장 효율적이지만, 미래의 페이지 참조를 예측할 수 없기 때문에 현실적으로 구현이 어려움.

**2-4. LRU 페이지 교체 (Least Recently Used)**\
**-** 가장 오랫동안 사용되지 않은 페이지를 교체함. 과거 사용 패턴을 기반으로 하므로 성능이 우수하지만, 참조 기록을 관리하는 데 추가 비용이 발생함.

**2-5. LFU 페이지 교체 (Least Frequently Used)**\
**-** 참조 횟수가 가장 적은 페이지를 교체함. 자주 사용되지 않는 페이지를 교체하는 방식이지만, 오랜 시간 전에 자주 사용된 페이지가 교체되지 않을 수 있어 단점이 있음.

**2-6. NUR (Not Used Recently)**\
**-** 최근에 사용되지 않은 페이지를 교체하는 방법. 참조 비트와 변경 비트를 기반으로 페이지를 교체함.

**2-7. FIFO 변형**\
**-** FIFO 알고리즘을 개선하여, 교체할 페이지를 선택할 때 최근에 참조된 페이지는 교체하지 않도록 변형함.

#### 3. **스레싱과 프레임 할당**

**3-1. 스레싱 (Thrashing)**\
**- 스레싱**은 프로세스가 필요한 페이지를 계속해서 디스크에서 불러오느라 실제 작업은 거의 진행되지 않는 상태. 페이지 부재가 자주 발생해 성능이 급격히 저하됨.

**3-2. 정적 할당 (Static Allocation)**\
**-** 프로세스가 시작될 때 고정된 수의 프레임을 할당받고, 실행 중에 할당된 프레임 수가 변하지 않음. 자원 관리가 쉬운 반면, 필요 이상으로 많은 프레임이 할당되거나 부족할 수 있음.

**3-3. 동적 할당 (Dynamic Allocation)**\
**-** 프로세스가 실행 중일 때 필요한 만큼의 프레임을 동적으로 할당받음. 시스템 상태에 따라 프레임을 조절할 수 있으므로 메모리 자원을 효율적으로 사용할 수 있음.

</details>

<details>

<summary>Chapter 10 : 입출력 시스템 / 저장장치</summary>

**1.** **입출력 시스템**

**1-1. 입출력 장치 / 채널**\
**- 입출력 장치**는 컴퓨터 시스템의 외부 장치와 데이터를 주고받는 장치. 키보드, 마우스, 프린터 등이 있음.\
\- **채널**은 중앙처리장치(CPU)와 입출력 장치 간의 데이터 전송을 관리함.

**1-2. 입출력 버스 구조**\
**- 버스**는 CPU, 메모리, 입출력 장치 간 데이터를 주고받는 통로. 시스템 버스, I/O 버스 등 다양한 형태가 존재.

**1-3. 직접 메모리 접근(DMA)**\
**- DMA(Direct Memory Access)**는 CPU의 개입 없이 입출력 장치가 메모리와 직접 데이터를 주고받을 수 있도록 하는 기술. CPU의 부담을 줄여 시스템 성능을 향상시킴.

**1-4. 인터럽트**\
**- 인터럽트**는 입출력 장치가 CPU에 작업을 요청하거나, 처리 완료를 알리는 신호. CPU가 다른 작업을 하다가도 인터럽트를 통해 입출력 작업을 처리할 수 있음.

**1-5. 버퍼링**\
**- 버퍼링**은 입출력 장치와 메모리 사이에 데이터를 임시로 저장하는 버퍼를 사용해 입출력 속도 차이를 보완하는 방식.

#### 2. **디스크 장치**

**2-1. 디스크 장치 종류**\
**- HDD**: 하드디스크 드라이브, 자성을 이용한 저장 장치.\
\- **SSD**: 솔리드 스테이트 드라이브, 반도체 메모리를 이용한 저장 장치로, 빠른 데이터 접근 속도를 제공함.

**2-2. 디스크 장치의 데이터 전송시간**\
**-** 데이터 전송 시간은 **탐색 시간(Seek Time)**, **회전 지연(Rotational Latency)**, **전송 시간(Transfer Time)**으로 구성됨.

**2-3. 디스크 장치 관리**\
**-** 디스크 장치의 **단편화**, **디스크 청소** 등을 통해 성능을 유지하고, 파일 시스템을 효율적으로 관리함.

**2-4. 네트워크 저장장치**\
**- NAS(Network Attached Storage)**: 네트워크를 통해 접근 가능한 저장 장치.\
\- **SAN(Storage Area Network)**: 고속 네트워크를 통해 연결된 고성능 스토리지 시스템.

#### 3. **디스크 스케줄링**

**3-1. FCFS (First-Come, First-Served)**\
**-** 먼저 요청된 디스크 작업을 먼저 처리하는 방식. 간단하지만 탐색 시간이 길어질 수 있음.

**3-2. SSTF (Shortest Seek Time First)**\
**-** 탐색 시간이 가장 짧은 요청을 먼저 처리하는 방식. 평균 탐색 시간을 줄일 수 있지만 기아(Starvation) 현상이 발생할 수 있음.

**3-3. 블록 SSTF**\
**-** SSTF 방식에서 여러 블록 요청을 동시에 처리하여 성능을 최적화하는 방식.

**3-4. SCAN**\
**-** 디스크 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하며 요청을 처리하는 방식. a.k.a 엘리베이터 알고리즘

**3-5. C-SCAN (Circular SCAN)**\
**-** SCAN 방식과 비슷하지만, 한쪽 끝에서 반대쪽 끝으로 바로 이동하며 다시 처리하는 방식.

**3-6. LOOK**\
**-** SCAN과 유사하지만, 마지막 요청까지 이동한 후 방향을 바꾸는 방식. 끝까지 이동하지 않음.

**3-7. C-LOOK**\
**-** C-SCAN과 유사하지만, 끝까지 가지 않고 가장 마지막 요청까지만 이동한 후 다시 처음으로 돌아옴.

#### 4. **RAID (Redundant Array of Independent Disks)**

**4-1. 개요** \
**-** 여러 개의 디스크를 배열해 데이터 안정성 및 성능을 향상시키는 기술.

**4-2. RAID 0**\
**-** 스트라이핑 방식. 성능이 향상되지만 데이터 중복은 없음.

**4-3. RAID 1**\
**-** 미러링 방식. 동일한 데이터를 복제해 저장하여 높은 데이터 안정성을 제공함.

**4-4. RAID 2**\
**-** 해밍 코드를 사용하여 오류를 검출하고 수정함.

**4-5. RAID 3**\
**-** 비트 단위의 스트라이핑과 함께 패리티 정보를 사용하여 오류를 검출함.

**4-6. RAID 4**\
**-** 블록 단위 스트라이핑을 사용하고, 별도의 디스크에 패리티 데이터를 저장함.

**4-7. RAID 5**\
**-** 블록 단위 스트라이핑과 패리티 정보를 분산 저장함. 성능과 안정성의 균형을 맞춤.

**4-8. RAID 6**\
**-** RAID 5에서 더 나아가 패리티 정보를 두 개의 디스크에 저장하여 더 높은 안정성을 제공함.

**4-9. RAID 10**\
**-** RAID 1과 RAID 0을 결합한 방식. 데이터를 미러링하고, 동시에 스트라이핑을 사용하여 성능과 안정성을 모두 향상시킴.

**4-10. RAID 50, 60**\
**-** RAID 5와 RAID 0, RAID 6과 RAID 0을 결합한 방식으로, 대규모 시스템에서 성능과 안정성을 모두 제공함.

</details>

<details>

<summary>Chapter 11 : 파일 시스템</summary>

**1.** **파일과 파일 시스템**

**1-1. 파일 시스템 개요**\
**- 파일 시스템**은 데이터를 저장하고 관리하기 위한 구조로, 파일을 조직화하고 접근할 수 있게 하는 방식.

**1-2. 파일 분류 / 확장자**\
**-** 파일은 **텍스트 파일**, **바이너리 파일** 등으로 분류됨.\
\- **확장자**는 파일 형식을 나타내며, 파일 끝에 붙는 특정 문자열(.txt, .jpg 등).

**1-3. 파일 이름과 연결 프로그램**\
**-** 파일 이름은 파일을 식별하는 데 사용됨. 확장자에 따라 파일을 열기 위한 **연결 프로그램**이 자동으로 지정될 수 있음.

**1-4. 파일 속성**\
**-** 파일의 **속성**은 파일의 읽기/쓰기 권한, 생성 및 수정 시간, 크기 등 파일에 대한 메타데이터를 포함함.

**1-5. 파일 작업 유형**\
**-** 파일 생성, 읽기, 쓰기, 삭제, 복사 등의 작업이 가능함.

**1-6. 파일 구조**\
**-** 파일은 **순차 파일**(Sequential Files) 또는 **임의 접근 파일**(Random Access Files)로 나눌 수 있음. 순차 파일은 데이터를 순서대로 저장하고, 임의 접근 파일은 어느 위치에서나 데이터를 읽고 쓸 수 있음.

#### 2. **디렉토리 구조**

**2-1. 디렉토리 개념**\
**-** 파일을 논리적으로 그룹화하여 관리하는 파일의 집합체.

**2-2. 디렉토리 파일**\
**- 디**파일과 디렉토리의 정보를 저장하는 특수한 파일로, 각 파일의 위치와 속성 등을 포함함.

**2-3. 경로**\
**-** 파일이나 디렉토리의 위치를 나타내는 문자열. 절대 경로와 상대 경로로 나뉨.\
\- **절대 경로**: 파일 시스템의 루트에서부터 파일이나 디렉토리까지의 전체 경로.\
\- **상대 경로**: 현재 위치를 기준으로 하는 경로.

**2-4. 디렉토리 구조**\
**-** 디렉토리 구조는 **단일 레벨**, **2단계 디렉토리**, **트리 구조** 등으로 나눌 수 있음.\
\- **단일 레벨 구조**: 모든 파일이 하나의 디렉토리 안에 존재.\
\- **2단계 디렉토리 구조**: 각 사용자가 별도의 디렉토리를 가짐.\
\- **트리 구조**: 계층적 구조로 디렉토리가 여러 하위 디렉토리를 포함할 수 있음.

**2-5. 마운트 (Mount)**\
**- 마운트**는 파일 시스템을 특정 디렉토리로 연결하여 접근할 수 있게 하는 작업. 예를 들어, USB 디스크를 마운트하여 사용할 수 있음.

#### 3. **디스크 파일 할당**

**3-1. 연속 할당 (Contiguous Allocation)**\
**-** 파일을 디스크의 연속된 블록에 할당하는 방식. 빠른 접근 속도를 제공하지만, 파일 크기가 변할 때 문제가 발생할 수 있음.

**3-2. 불연속 할당 (Non-contiguous Allocation)**\
**-** 파일을 여러 블록에 나누어 할당하는 방식. 연속된 공간을 확보할 필요가 없어 유연성이 있음.

4\. **디스크 빈공간 관리**\
**-** 디스크의 빈 공간을 효율적으로 관리하는 방법\
\- **프리 리스트(Free List)**나 **비트맵(Bit Map)**을 사용해 빈 블록을 추적함.\
\- **프리 리스트**: 빈 블록들의 목록을 유지.\
\- **비트맵**: 디스크의 각 블록이 사용 중인지 아닌지를 비트로 표현해 관리.

</details>

<details>

<summary>Chapter 12 : 네트워크와 분산 시스템</summary>

**1.** **네트워크와 인터넷**

**1-1. 통신과 네트워크**\
**- 통신:** 두 개 이상의 장치가 데이터를 주고받는 과정.\
\- **네트워크:** 이러한 통신을 가능하게 하는 시스템으로, 여러 장치들을 연결해 데이터를 전송하는 구조. \
\- LAN, WAN, MAN 등 다양한 규모의 네트워크가 있음.

**1-2. 인터넷**\
**-** 전 세계적으로 연결된 네트워크들의 집합. TCP/IP 프로토콜을 사용하여 데이터를 교환하며, 웹, 이메일, 파일 전송 등의 다양한 서비스를 제공함.

#### 2. **분산 시스템**

**2-1. 개요**\
**- 분산 시스템**은 여러 대의 컴퓨터가 네트워크를 통해 서로 협력하여 하나의 시스템처럼 동작하는 구조. 자원을 공유하고 병렬 처리할 수 있어 효율성이 높음.

**2-2. 클라이언트-서버 시스템**\
**- 클라이언트-서버 시스템**은 클라이언트(사용자)가 요청을 보내고, 서버가 해당 요청을 처리해 응답하는 구조. 대부분의 웹 애플리케이션, 데이터베이스 시스템이 이 구조를 사용함.

**2-3. P2P 시스템 (Peer-to-Peer)**\
**- P2P 시스템**은 중앙 서버 없이 모든 참여자가 동등한 지위에서 자원을 공유하는 시스템. 각 노드가 클라이언트이자 서버의 역할을 동시에 함. 대표적인 예로 파일 공유 시스템이 있음.

**2-4. 클라우드 컴퓨팅**\
**- 클라우드 컴퓨팅**은 인터넷을 통해 컴퓨팅 자원(서버, 스토리지, 데이터베이스 등)을 제공하는 기술. 사용자는 물리적인 하드웨어에 의존하지 않고, 필요할 때 자원을 임대하여 사용함. 대표적으로 AWS, Google Cloud&#x20;

</details>
